{
var require = function(nop) {};
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var vm = require("./machine");
(function (Operator) {
    Operator[Operator["Add"] = 0] = "Add";
    Operator[Operator["Subtract"] = 1] = "Subtract";
    Operator[Operator["Multiply"] = 2] = "Multiply";
    Operator[Operator["Divide"] = 3] = "Divide";
})(exports.Operator || (exports.Operator = {}));
var Operator = exports.Operator;
var OperatorUtils = (function () {
    function OperatorUtils() {
    }
    OperatorUtils.fromChar = function (c) {
        switch (c) {
            case "+": return Operator.Add;
            case "-": return Operator.Subtract;
            case "*": return Operator.Multiply;
            case "/": return Operator.Divide;
        }
    };
    OperatorUtils.toChar = function (o) {
        switch (o) {
            case Operator.Add: return "+";
            case Operator.Subtract: return "-";
            case Operator.Multiply: return "*";
            case Operator.Divide: return "/";
        }
    };
    OperatorUtils.toFunc = function (o) {
        switch (o) {
            case Operator.Add: return function (l, r) { return l + r; };
            case Operator.Subtract: return function (l, r) { return l - r; };
            case Operator.Multiply: return function (l, r) { return l * r; };
            case Operator.Divide: return function (l, r) { return l / r; };
        }
    };
    return OperatorUtils;
}());
exports.OperatorUtils = OperatorUtils;
var ASTNode = (function () {
    function ASTNode() {
    }
    ASTNode.prototype.fixPrototype = function (langModule) {
        var className = this.constructor.name;
        this.__proto__ = langModule[className].prototype;
    };
    return ASTNode;
}());
exports.ASTNode = ASTNode;
var Expression = (function (_super) {
    __extends(Expression, _super);
    function Expression() {
        _super.apply(this, arguments);
    }
    return Expression;
}(ASTNode));
exports.Expression = Expression;
var Integer = (function (_super) {
    __extends(Integer, _super);
    function Integer(value) {
        if (value === void 0) { value = 0; }
        _super.call(this);
        this.value = value;
    }
    Integer.prototype.codegen = function (machine) {
        machine.beginASTRange(this);
        machine.addInstruction(new vm.Push(this.value));
        machine.endASTRange(this);
    };
    return Integer;
}(Expression));
exports.Integer = Integer;
var ValueExpression = (function (_super) {
    __extends(ValueExpression, _super);
    function ValueExpression(ident) {
        if (ident === void 0) { ident = new EmptyIdent(); }
        _super.call(this);
        this.ident = ident;
    }
    ValueExpression.prototype.codegen = function (machine) {
        machine.beginASTRange(this);
        if (this.ident instanceof ConcreteIdent) {
            machine.addInstruction(new vm.Get(this.ident.name));
        }
        machine.endASTRange(this);
    };
    ValueExpression.prototype.fixPrototype = function (langModule) {
        _super.prototype.fixPrototype.call(this, langModule);
        this.ident.fixPrototype(langModule);
    };
    return ValueExpression;
}(Expression));
exports.ValueExpression = ValueExpression;
var BinaryExpression = (function (_super) {
    __extends(BinaryExpression, _super);
    function BinaryExpression(left, right, op) {
        if (left === void 0) { left = new EmptyExpression(); }
        if (right === void 0) { right = new EmptyExpression(); }
        _super.call(this);
        this.left = left;
        this.right = right;
        this.op = op;
    }
    BinaryExpression.prototype.codegen = function (machine) {
        machine.beginASTRange(this);
        this.left.codegen(machine);
        this.right.codegen(machine);
        machine.addInstruction(new vm.CallFunction(vm.builtInFunctions[this.op]));
        machine.endASTRange(this);
    };
    BinaryExpression.prototype.fixPrototype = function (langModule) {
        _super.prototype.fixPrototype.call(this, langModule);
        this.left.fixPrototype(langModule);
        this.right.fixPrototype(langModule);
    };
    return BinaryExpression;
}(Expression));
exports.BinaryExpression = BinaryExpression;
var EmptyExpression = (function (_super) {
    __extends(EmptyExpression, _super);
    function EmptyExpression() {
        _super.call(this);
    }
    EmptyExpression.prototype.codegen = function (machine) {
        machine.beginASTRange(this);
        machine.endASTRange(this);
    };
    return EmptyExpression;
}(Expression));
exports.EmptyExpression = EmptyExpression;
var Statements = (function (_super) {
    __extends(Statements, _super);
    function Statements(statements) {
        _super.call(this);
        this.statements = statements;
    }
    Statements.prototype.codegen = function (machine) {
        machine.beginASTRange(this);
        this.statements.forEach(function (statement) { return statement.codegen(machine); });
        machine.endASTRange(this);
    };
    Statements.prototype.fixPrototype = function (langModule) {
        _super.prototype.fixPrototype.call(this, langModule);
        this.statements.forEach(function (statement) { return statement.fixPrototype(langModule); });
    };
    return Statements;
}(ASTNode));
exports.Statements = Statements;
var Statement = (function (_super) {
    __extends(Statement, _super);
    function Statement() {
        _super.apply(this, arguments);
    }
    return Statement;
}(ASTNode));
exports.Statement = Statement;
var AssignmentStatement = (function (_super) {
    __extends(AssignmentStatement, _super);
    function AssignmentStatement(ident, expression) {
        if (ident === void 0) { ident = new EmptyIdent(); }
        if (expression === void 0) { expression = new EmptyExpression(); }
        _super.call(this);
        this.ident = ident;
        this.expression = expression;
    }
    AssignmentStatement.prototype.codegen = function (machine) {
        machine.beginASTRange(this);
        this.expression.codegen(machine);
        if (this.ident instanceof ConcreteIdent) {
            machine.addInstruction(new vm.Set(this.ident.name));
        }
        machine.endASTRange(this);
    };
    AssignmentStatement.prototype.fixPrototype = function (langModule) {
        _super.prototype.fixPrototype.call(this, langModule);
        this.ident.fixPrototype(langModule);
        this.expression.fixPrototype(langModule);
    };
    return AssignmentStatement;
}(Statement));
exports.AssignmentStatement = AssignmentStatement;
var WhileStatement = (function (_super) {
    __extends(WhileStatement, _super);
    function WhileStatement(condition, statements) {
        if (condition === void 0) { condition = new EmptyExpression(); }
        if (statements === void 0) { statements = new Statements([]); }
        _super.call(this);
        this.condition = condition;
        this.statements = statements;
    }
    WhileStatement.prototype.codegen = function (machine) {
        machine.beginASTRange(this);
        var whileBeginLabel = "whileBegin";
        var whileEndLabel = "whileEnd";
        machine.addLabel(whileBeginLabel);
        this.condition.codegen(machine);
        machine.addInstruction(new vm.CallFunction(vm.builtInFunctions['!']));
        machine.addInstruction(new vm.IfGoto(whileEndLabel));
        this.statements.codegen(machine);
        machine.addInstruction(new vm.Push(1));
        machine.addInstruction(new vm.IfGoto(whileBeginLabel));
        machine.addLabel(whileEndLabel);
        machine.endASTRange(this);
    };
    WhileStatement.prototype.fixPrototype = function (langModule) {
        _super.prototype.fixPrototype.call(this, langModule);
        this.condition.fixPrototype(langModule);
        this.statements.fixPrototype(langModule);
    };
    return WhileStatement;
}(Statement));
exports.WhileStatement = WhileStatement;
var EmptyStatement = (function (_super) {
    __extends(EmptyStatement, _super);
    function EmptyStatement() {
        _super.call(this);
    }
    EmptyStatement.prototype.codegen = function (machine) {
        machine.beginASTRange(this);
        machine.endASTRange(this);
    };
    return EmptyStatement;
}(Statement));
exports.EmptyStatement = EmptyStatement;
var Ident = (function (_super) {
    __extends(Ident, _super);
    function Ident() {
        _super.apply(this, arguments);
    }
    return Ident;
}(ASTNode));
exports.Ident = Ident;
var EmptyIdent = (function (_super) {
    __extends(EmptyIdent, _super);
    function EmptyIdent() {
        _super.call(this);
    }
    EmptyIdent.prototype.codegen = function (machine) {
        machine.beginASTRange(this);
        machine.endASTRange(this);
    };
    return EmptyIdent;
}(Ident));
exports.EmptyIdent = EmptyIdent;
var ConcreteIdent = (function (_super) {
    __extends(ConcreteIdent, _super);
    function ConcreteIdent(name) {
        _super.call(this);
        this.name = name;
    }
    ConcreteIdent.prototype.codegen = function (machine) {
        machine.beginASTRange(this);
        machine.endASTRange(this);
    };
    return ConcreteIdent;
}(Ident));
exports.ConcreteIdent = ConcreteIdent;
function getMatchingStatementTypes(input) {
    return [AssignmentStatement, WhileStatement]
        .filter(function (statementType) { return statementType.name.indexOf(input) != -1; })
        .map(function (statementType) { return new statementType(); });
}
exports.getMatchingStatementTypes = getMatchingStatementTypes;
function getMatchingExpressionTypes(input) {
    return [BinaryExpression, ValueExpression, Integer]
        .filter(function (expressionType) { return expressionType.name.indexOf(input) != -1; })
        .map(function (expressionType) { return new expressionType(); });
}
exports.getMatchingExpressionTypes = getMatchingExpressionTypes;
function getMatchingIdentTypes(input) {
    return [new ConcreteIdent(input)];
}
exports.getMatchingIdentTypes = getMatchingIdentTypes;
var Method = (function (_super) {
    __extends(Method, _super);
    function Method(name, args, statements) {
        _super.call(this);
        this.name = name;
        this.args = args;
        this.statements = statements;
    }
    Method.prototype.codegen = function (machine) {
        machine.beginASTRange(this);
        this.statements.codegen(machine);
        machine.endASTRange(this);
    };
    Method.prototype.fixPrototype = function (langModule) {
        _super.prototype.fixPrototype.call(this, langModule);
        this.name.fixPrototype(langModule);
        this.args.forEach(function (arg) { return arg.fixPrototype(langModule); });
        this.statements.fixPrototype(langModule);
    };
    return Method;
}(ASTNode));
exports.Method = Method;
}
start
  = w method w

method
  = "method" w i:ident w "(" w args:ident* w ")" w "{" w s:statements w "}" { return new Method(i, args, s)}

statements
  = s:statement* { return new Statements(s)}

statement
  = assignmentStatement
  / whileStatement

assignmentStatement
  = "let" w i:ident w ":=" w e:expression w { return new AssignmentStatement(i, e); }

whileStatement
  = "while" w "(" w c:expression w ")" w "do" w "{" w s:statements w "}" w { return new WhileStatement(c, s); }

expression
  = additive
  / multiplicative

additive
  = left:multiplicative w "+" w right:additive { return new BinaryExpression(left, right, "+"); }
  / left:multiplicative w "-" w right:additive { return new BinaryExpression(left, right, "-"); }
  / multiplicative

multiplicative
  = left:primary w "*" w right:multiplicative { return new BinaryExpression(left, right, "*"); }
  / left:primary w "/" w right:multiplicative { return new BinaryExpression(left, right, "/"); }
  / primary

value
  = i:ident { return new ValueExpression(i); }

primary
  = value
  / integer
  / "(" w additive:additive w ")" { return additive; }

integer "integer"
  = digits:[0-9]+ { return new Integer(parseInt(digits.join(""), 10)); }

ident
  = name:[a-z]+ { return new ConcreteIdent(name.join("")) }

w
  = [ \t\n\r]*
